# __init__.py


# main.py
from softwareWithWindow import MainWindow
from PyQt5.QtWidgets import QApplication
import sys

def main():
	try:
		app = QApplication(sys.argv)
		window = MainWindow()
		window.show()
		sys.exit(app.exec_())
	except Exception as e:
		import traceback
		print("[Unhandled exception]: ")
		traceback.print_exc()
		input("Press Enter to exit...")

if __name__ == "__main__":
	main()


# FuriganaAdditionPackaged.py
import os
import sys
import pandas as pd
import copy
from openpyxl import styles

APP_NAME = "FAPSoftware"
    
def resource_path(relative):
    if getattr(sys, "_MEIPASS", False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative)

def sort_list(lst):

    '''
    Sort list by the length of Japanese of every element through merge.
    '''
    
    length = len(lst)
    if length in [0,1]:
        return lst
    m = sort_list(lst[0: length//2])
    n = sort_list(lst[length//2: length])
    new_list = []
    i = j = 0
    while i < len(m) and j < len(n):
        if len(simplify(m[i][0])) >= len(simplify(n[j][0])):
            new_list.append(m[i])
            i+=1
        else:
            new_list.append(n[j])
            j+=1
    new_list = new_list + m[i:] + n[j:]
    return new_list

def simplify(term):
    temp = ''
    for i in term:
        if i not in r'\/':
            temp = temp+i
    return temp

class Dictionary:
    def __init__(self, dic_path=resource_path(os.path.join("data", "Dictionary.xlsx"))):
        self.dic_address = dic_path
        self.dic = pd.read_excel(self.dic_address)
        self.shape = self.dic.shape

    def outputdf(self):
        return copy.deepcopy(self.dic)
    
    def outputList(self):
        l=[]
        for i in range(self.dic.shape[0]):
            l.append(Term(list(self.dic.loc[i])))
        return l
    
    def isExists(self, l):
        for i in range(self.dic.shape[0]):
            if list(self.dic.loc[i])==l:
                return True
        return False
    
    def outputClassifiedList(self):
        df = self.outputdf()
        df.sort_values("Japanese")
        lst = [[], [], []]
        for i in range(df.index.stop):
            temp = list(df.loc[i])
            for i in range(4):
                temp[i] = JpString(temp[i])
            temp[4] = int(temp[4])
            lst[temp[4]].append(temp[:4])
        return [sort_list(lst[1])+sort_list(lst[0]), sort_list(lst[2])]
    
    def __getitem__(self, key):
        return Term(list(self.dic.loc[key]))
    
    def dfappend(self, l):
        new_l = self.outputList()
        new_l.append(l)
        return pd.DataFrame(new_l, columns=self.dic.columns)
    
    def isIndf(self, l):
        outputList = self.outputList()
        new_l = [JpString(i) for i in l]
        for i in range(len(outputList)):
            if outputList[i] == new_l:
                return True
        return False
    
    def savedf(self, df):
        with pd.ExcelWriter(self.dic_address, engine="openpyxl") as writer:
            df.to_excel(writer, sheet_name="Sheet1", index=False)
            workbook = writer.book
            worksheet = workbook["Sheet1"]
            for c in "ABCDE":
                for cell in worksheet[c]:
                    cell.font = styles.Font(name="Corporate Logo Bold", sz=14)
            workbook.save(self.dic_address)

    def delete(self, index):
        df = self.outputdf()
        tempList = self.outputList()
        tempList = tempList[:index]+tempList[index+1:]
        new_df = pd.DataFrame(tempList, columns=df.columns)
        self.savedf(new_df)
        
    
class JpString(str):
    def __new__(cls, value):
        return super().__new__(cls, value)

    def __getitem__(self, index):
        result = super().__getitem__(index)
        if isinstance(result, str):
            return JpString(result)
        return result
        

    def __getattribute__(self, name):
        attr = super().__getattribute__(name)

        if callable(attr) and name not in dir(str):
            def wrapper(*args, **kwargs):
                result = attr(*args, **kwargs)
                if isinstance(result, str):
                    return JpString(result)
                return result
            return wrapper
        return attr
    
    def __add__(self, other):
        return JpString(super().__add__(other))
    
    def __mul__(self, other):
        return JpString(super().__mul__(other))
    
    def string_division(self):
        tempString = "/"+self
        tempSubstring = JpString("")
        tempValue = 0
        tempMap = []
        for i in range(len(tempString)):
            if tempString[i]=="/":
                if i != 0:
                    tempMap.append((tempSubstring, tempValue))
                    tempValue=0
                    tempSubstring=JpString("")
            elif tempString[i]=="\\":
                tempMap.append((tempSubstring, tempValue))
                tempValue=1
                tempSubstring=JpString("")
            else:
                tempSubstring+=tempString[i]
        tempMap.append((tempSubstring, tempValue))
        return tempMap
    
    def isHiragana(self):
        return len(self)==1 and 12353<=ord(self)<=12436
    
    def isKatakana(self):
        return len(self)==1 and 12449<=ord(self)<=12538
    
    def isKana(self):
        return self.isHiragana() or self.isKatakana()
    
    def isSameKana(self, other):
        if not isinstance(other, JpString):
            return False
        if not self.isKana() or not other.isKana():
            return False
        c1 = copy.deepcopy(self)
        c2 = copy.deepcopy(other)
        if c1.isHiragana():
            c1 = JpString(chr(ord(c1)+96))
        if c2.isHiragana():
            c2 = JpString(chr(ord(c2)+96))
        return c1==c2
    
    def isSameString(self, other):
        if not isinstance(other, JpString):
            return False
        if len(self)!=len(other):
            return False
        s1 = JpString(self.upper())
        s2 = JpString(other.upper())
        for i in range(len(s1)):
            if not s1[i].isSameKana(s2[i]) and s1[i]!=s2[i]:
                return False
        return True
    
    def isAllKana(self):
        flag = False
        for i in self:
            if JpString(i).isKana():
                flag = True
            if flag and not JpString(i).isKana():
                return -1
        return 0 if flag else 1
    

class Term(list):
    def __init__(self, *args):
        l = [JpString(i) for i in args[0]]
        super().__init__(l)
        self.Japanese_division = self[0].string_division()
        self.Kana_division = self[1].string_division()
        self.Division_division = self[2].string_division()

    def isLegal(self):
        return self.isMatch() and self.isDivisionMatch() and self.isTypeMatch()

    def isMatch(self):
        if (len(self.Japanese_division)!=len(self.Kana_division)
            or len(self.Kana_division)!=len(self.Division_division)):
            return False
        for i in range(len(self.Kana_division)):
            if (self.Japanese_division[i][1]!=self.Kana_division[i][1]
                or self.Kana_division[i][1]!=self.Division_division[i][1]):
                return False
        return True
    
    def isDivisionMatch(self):
        for i in range(len(self.Kana_division)):
            if self.Division_division[i][0]=="0":
                if (self.Japanese_division[i][0].isAllKana()!=1
                    or self.Kana_division[i][0].isAllKana()!=0):
                    return False
            elif self.Division_division[i][0]=="-1":
                if (self.Kana_division[i][0].isAllKana()!=0
                    or not self.Japanese_division[i][0].isSameString(self.Kana_division[i][0])):
                    return False
            else:
                return False
        return True
    
    def isTypeMatch(self):
        match self[3]:
            case "五段":
                if (self.Division_division[-1][1]==1 and
                    self.Japanese_division[-1][0] in "うくすつぬむるぐぶ"):
                    return True
            case "上下":
                if (self.Division_division[-1][1]==1 and
                    self.Japanese_division[-1][0]=="る"):
                    return True
            case "形容":
                if (self.Division_division[-1][1]==1 and
                    self.Japanese_division[-1][0]=="い"):
                    return True
            case "サ行":
                if (self.Division_division[-1][1]==1 and
                    self.Japanese_division[-1][0]=="する"):
                    return True
            case ("タ行"|"名詞"):
                if self.Division_division[-1][1]==0:
                    return True
        return False
    
    def AutoDivision_Japanese(self, Japanese):
        templist = []
        tempJpString = ""
        flag = Japanese[0].isKana()
        for i in range(len(Japanese)):
            if flag==Japanese[i].isKana():
                tempJpString += Japanese[i]
            else:
                if flag:
                    templist.append([tempJpString, "-1"])
                else:
                    templist.append([tempJpString, "0"])
                tempJpString = Japanese[i]
                flag = not flag
        if flag:
            templist.append([tempJpString, "-1"])
        else:
            templist.append([tempJpString, "0"])
        return templist
    
    def AutoDivision_Kana(self, Japanese, Kana):
        templist = []
        tempCount = 0
        tempStart = 0
        flag = Japanese[0][1]=="-1"
        tempIndex = 0 if flag else len(Japanese[tempCount][0])
        if tempIndex >= len(Kana):
            templist.append([Kana[tempStart:], "0"])
        while tempIndex<len(Kana) and tempCount<len(Japanese):
            if flag:
                if Kana[tempIndex: tempIndex+len(Japanese[tempCount][0])]==Japanese[tempCount][0]:
                    templist.append([Japanese[tempCount][0], "-1"])
                    tempIndex += len(Japanese[tempCount][0])
                    tempStart = tempIndex
                    tempAddition = len(Japanese[tempCount][0])
                    tempIndex += tempAddition if tempIndex+tempAddition<len(Kana) else 0
                    tempCount += 1
                    flag = not flag
                else:
                    raise ValueError("Invalid Kana input")
            else:
                if tempCount==len(Japanese)-1:
                    templist.append([Kana[tempStart:], "0"])
                    break
                elif Kana[tempIndex: tempIndex+len(Japanese[tempCount+1][0])]==Japanese[tempCount+1][0]:
                    templist.append([Kana[tempStart: tempIndex], "0"])
                    flag = not flag
                    tempCount += 1
                else:
                    tempIndex += 1
        return templist
    
    def AutoDivision_Type(self, Japanese, Kana, Type):
        newlist = []
        match Type:
            case "五段":
                if (Japanese[-1][0][-1] not in "うくすつぬむるぐぶ" or
                    Kana[-1][0][-1] not in "うくすつぬむるぐぶ" or Japanese[-1][0][-1]!=Kana[-1][0][-1]):
                    raise ValueError("Invalid Kana input")
                newlist.append(Japanese[:-1]+[[Japanese[-1][0][:-1], "-1"]]+[[Japanese[-1][0][-1], "-2"]])
                newlist.append(Kana[:-1]+[[Kana[-1][0][:-1], "-1"]]+[[Kana[-1][0][-1], "-2"]])
            case ("上下"|"形容") as x:
                dic = {"上下":"る", "形容":"い"}
                if (Japanese[-1][0][-1]!=dic[x] or Kana[-1][0][-1]!=dic[x]):
                    raise ValueError("Invalid Kana input")
                newlist.append(Japanese[:-1]+[[Japanese[-1][0][:-1], "-1"]]+[[Japanese[-1][0][-1], "-2"]])
                newlist.append(Kana[:-1]+[[Kana[-1][0][:-1], "-1"]]+[[Kana[-1][0][-1], "-2"]])
            case "サ行":
                if (Japanese[-1][0][-2:]!="する" or Kana[-1][0][-2:]!="する"):
                    raise ValueError("Invalid Kana input")
                newlist.append(Japanese[:-1]+[[Japanese[-1][0][:-2], "-1"]]+[[Japanese[-1][0][-2:], "-2"]])
                newlist.append(Kana[:-1]+[[Kana[-1][0][:-2], "-1"]]+[[Kana[-1][0][-2:], "-2"]])
            case _:
                newlist = [Japanese, Kana]
        templist = [newlist[0][0][0], newlist[1][0][0], newlist[0][0][1]]
        for i in range(1, len(newlist[0])):
            if newlist[0][i][0]!="":
                if newlist[0][i][1] in ("0", "-1"):
                    templist[0] += "/"+newlist[0][i][0]
                    templist[1] += "/"+newlist[1][i][0]
                    templist[2] += "/"+newlist[0][i][1]
                elif newlist[0][i][1]=="-2":
                    templist[0] += "\\"+newlist[0][i][0]
                    templist[1] += "\\"+newlist[1][i][0]
                    templist[2] += "\\-1"
        return templist
    
    def AutoDivision(self):
        tempTerm = copy.deepcopy(self)
        templist = [[], []]
        templist[0] = self.AutoDivision_Japanese(tempTerm[0])
        templist[1] = self.AutoDivision_Kana(templist[0], tempTerm[1])
        templist = self.AutoDivision_Type(*templist, tempTerm[3])
        return Term([*templist, *tempTerm[3:]])
    
class InText():
    def __init__(self, in_text_path=resource_path(os.path.join("data", "in.txt"))):
        self.file_address = in_text_path

    def read_text(self):
        file = open(self.file_address, mode='r')
        text = file.read()
        file.close()
        return text
    
    def write_text(self, text):
        file = open(self.file_address, mode='w')
        file.write(text)
        file.close()

class OutText():
    def __init__(self, out_text_path=resource_path(os.path.join("data", "out.txt"))):
        self.file_address = out_text_path
        
    def read_text(self):
        file = open(self.file_address, mode='r')
        text = file.read()
        file.close()
        return text
    
    def write_text(self, text):
        file = open(self.file_address, mode='w')
        file.write(text)
        file.close()

class Addition:
    def __init__(self):
        self.MOE = 0
        pass

    def operation(self, intext=InText(), outtext = OutText()):
        outtext.write_text(self.process(intext.read_text()))
        pass

    def process(self, text):
        new_text = text
        i = 0
        dic = Dictionary().outputClassifiedList()
        while i < len(new_text):
            dic_index = 0
            if new_text[i:i+2] == "${":
                new_text = new_text[:i]+new_text[i+2:]
                while new_text[i]!="}":
                    i+=1
                new_text = new_text[:i]+new_text[i+1:]
                continue
            if new_text[i] == "$":
                new_text = new_text[:i]+new_text[i+1:]
                i+=1
                continue
            if new_text[i] == "@":
                new_text = new_text[:i]+new_text[i+1:]
                dic_index = 1
            dic_sub = dic[dic_index]
            for j in range(len(dic_sub)):
                new_text, i = self.check(new_text, i, dic_sub[j])
            i+=1
        return new_text

    def printform(self, term):
        new_term = list(term)[:3]
        for i in range(3):
            if '\\' in new_term[i]:
                new_term[i] = new_term[i].split('\\')
                new_term[i] = new_term[i][0]
            new_term[i] = new_term[i].split('/')
        temp = ''
        for i in range(len(new_term[2])):
            if new_term[2][i] == '0':
                if(self.MOE == 0):
                    temp+=new_term[0][i]+'('+new_term[1][i]+')'
                else:
                    temp+="{}photrans|{}|{}{}".format("{{", new_term[0][i], new_term[1][i], "}}")
            else:
                temp+=new_term[0][i]
        return temp
    
    def meishi(self, new_line, j, term):
        temp = simplify(term[0])
        if new_line[j:j+len(temp)] == temp:
            new_line = new_line[:j] + self.printform(term) + new_line[j+len(temp):]
            j+=len(self.printform(term))-1
        return new_line, j
    
    def godann(self, new_line, j, term):
        temp = simplify(term[0])
        gobi = {'う':'わいうえおっ',
                'く':'かきくけこい',
                'す':'さしすせそ',
                'つ':'たちつてとっ',
                'ぬ':'なにぬねのん',
                'む':'まみむめもん',
                'る':'らりるれろっ',
                'ぐ':'がぎぐげごい',
                'ぶ':'ばびぶべぼん'}
        if (new_line[j:j+len(temp)-1] == temp[:-1] and
            j+len(temp)-1<len(new_line) and
            new_line[j+len(temp)-1] in gobi[temp[-1]]):
            new_line = new_line[:j] + self.printform(term) + new_line[j+len(temp)-1:]
            j+=len(self.printform(term))
        return new_line, j
    
    def kamishimo(self, new_line, j, term):
        temp = simplify(term[0])
        if new_line[j:j+len(temp)-1] == temp[:-1]:
            new_line = new_line[:j] + self.printform(term) + new_line[j+len(temp)-1:]
            j+= len(self.printform(term))-1
        return new_line, j
    
    def tagyou(self, new_line, j, term):
        gokann = ['来/る','来/ま','来/なさ','来/な','来/た','来/て',
                '来/られ','来/させ','来/い','来/よ']
        yomikata = ['く/る','き/ま','き/なさ','こ/な','き/た',
                    'き/て','こ/られ','こ/させ','こ/い','こ/よ']
        for i in range(len(gokann)):
            temp = simplify(gokann[i])
            if new_line[j:j+len(temp)] == temp:
                new_line = new_line[:j] + self.printform([gokann[i],yomikata[i],'0/-1','タ行']) + new_line[j+len(temp):]
                j+=len(self.printform([gokann[i],yomikata[i],'0/-1','タ行']))-1
                break
        return new_line, j
    
    def sagyou(self, new_line, j, term):
        gokann = ['する', 'し', 'せず', 'せよ', 'させ', 'され']
        for i in range(len(gokann)):
            temp = simplify(term[0])[:-2]
            if (new_line[j:j+len(temp)] == temp and
                new_line[j+len(temp):j+len(temp)+len(gokann[i])] == gokann[i]):
                new_line = new_line[:j] + self.printform(term) + new_line[j+len(temp):]
                j+=len(self.printform(term))
                break
        return new_line, j
    
    def keiyou(self, new_line, j, term):
        temp = simplify(term[0])
        gobi = ['い','かった','く','ければ','がる','がり','がら',
                'がれ','がろ','がっ','げ','さ','すぎ','過ぎ']
        for i in range(len(gobi)):
            if (new_line[j:j+len(temp)-1] == temp[:-1] and
                new_line[j+len(temp)-1:j+len(temp)-1+len(gobi[i])] == gobi[i]):
                new_line = new_line[:j] + self.printform(term) + new_line[j+len(temp)-1:]
                j+=len(self.printform(term))-1
                break
        return new_line, j
    
    def check(self, new_line, j , term):
        match term[3]:
            case JpString('五段'):
                new_line, j = self.godann(new_line, j, term)
            case JpString('上下'):
                new_line, j = self.kamishimo(new_line, j, term)
            case JpString('タ行'):
                new_line, j = self.tagyou(new_line, j, term)
            case JpString('形容'):
                new_line, j = self.keiyou(new_line, j, term)
            case JpString('サ行'):
                new_line, j = self.sagyou(new_line, j, term)
            case JpString('名詞'):
                new_line, j = self.meishi(new_line, j, term)
        return new_line, j


def main():
    addition = Addition()
    addition.operation()
    return

if __name__ == "__main__":
    main()


# CustomPyQt5.py
import os
import sys
import pandas as pd
from PyQt5.QtWidgets import (
	QWidget, QPushButton, QGridLayout,
	QTableView, QLineEdit, QComboBox, QFileDialog
)
from PyQt5.QtGui import (
	QStandardItemModel, QStandardItem
)
from PyQt5.QtCore import Qt
import json

class SettingJson:
	def __init__(self, appname):
		self.CONFIG_DIR = self.get_config_dir(appname)
		self.CONFIG_FILE = "setting.json"

	def save_settings(self, settings):
		config_file = os.path.join(self.CONFIG_DIR, self.CONFIG_FILE)
		with open(config_file, "w", encoding="utf-8") as f:
			json.dump(settings, f, ensure_ascii=False, indent=4)

	def load_settings(self):
		config_file = os.path.join(self.CONFIG_DIR, self.CONFIG_FILE)
		if os.path.exists(config_file):
			with open(config_file, "r", encoding="utf-8") as f:
				return json.load(f)
		return {}
	
	def get_config_dir(self, appname):
		if sys.platform == "darwin":
			config_dir = os.path.expanduser("~/Library/Application Support/{}".format(appname))
		elif sys.platform == "win32":
			config_dir = os.path.join(os.getenv("APPDATA"), appname)
		else:
			config_dir = os.path.expanduser("~/.{}".format(appname))

		os.makedirs(config_dir, exist_ok=True)
		return config_dir

class DataFrameViewer(QWidget):

	def __init__(self, parent=None):
		super().__init__(parent)
		self.model = QStandardItemModel()
		self.table_view = QTableView()
		self.table_view.setModel(self.model)

		layout = QGridLayout()
		layout.addWidget(self.table_view, 0, 0)
		self.setLayout(layout)

	def load_data(self, df: pd.DataFrame):
		self.model.setRowCount(0)
		self.model.setColumnCount(len(df.columns))
		self.model.setHorizontalHeaderLabels([str(col) for col in df.columns])

		for row in df.itertuples(index=False):
			items = [QStandardItem(str(field)) for field in row]
			self.model.appendRow(items)

class NavigableMixin:

	def __init__(self, row: int, col: int):
		self.row = row
		self.col = col

	def move_to(self, dx: int, dy: int):
		layout = self.parent().layout()
		if layout is None:
			return None
		
		new_row = self.row+dy
		new_col = self.col+dx

		for i in range(layout.count()):
			item = layout.itemAt(i)
			widget = item.widget()
			if (isinstance(widget, (CustomButton, CustomComboBox, CustomLineEdit)) and 
				hasattr(widget, "row") and hasattr(widget, "col")):
				if widget.row==new_row and widget.col==new_col:
					widget.setFocus()
					widget.setCursorToEdge(dx)
					break

	def setCursorToEdge(self, dx: int):
		pass
	
class CustomButton(NavigableMixin, QPushButton):
	def __init__(self, row: int, col: int, text: str="", parent=None):
		QPushButton.__init__(self, text, parent)
		NavigableMixin.__init__(self, row, col)
		self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

		self.defalut_style = self.styleSheet()
		self.focused_style = '''QPushButton {
		border: 0.2px solid white;
		border-radius: 5px;
		padding: 2px;
		background-color: #0060E4;
		color: white;
		}'''
		self.on_click = self.BlankFunction

	def keyPressEvent(self, event):
		if event.type()==event.KeyPress:
			if event.key()==Qt.Key.Key_Left:
				self.move_to(-1, 0)
			elif event.key()==Qt.Key.Key_Right:
				self.move_to(1, 0)
			elif event.key()==Qt.Key.Key_Up:
				self.move_to(0, -1)
			elif event.key()==Qt.Key.Key_Down:
				self.move_to(0, 1)
			elif event.key()==Qt.Key.Key_Return or event.key()==Qt.Key.Key_Enter:
				self.on_click_func()
			else:
				super().keyPressEvent(event)

	def setOnClick(self, func):
		self.on_click = func
		self.clicked.connect(self.on_click_func)

	def on_click_func(self):
		self.on_click()
		self.clearFocus()

	def BlankFunction(self):
		pass

	def setCursorToEdge(self, dx):
		pass

	def focusInEvent(self, event):
		self.setStyleSheet(self.focused_style)
		return super().focusInEvent(event)
	
	def focusOutEvent(self, event):
		self.setStyleSheet(self.defalut_style)
		return super().focusOutEvent(event)

class CustomLineEdit(NavigableMixin, QLineEdit):
	def __init__(self, row, col, placeholder, parent=None):
		QLineEdit.__init__(self, parent)
		NavigableMixin.__init__(self, row, col)
		self.setPlaceholderText(placeholder)

	def keyPressEvent(self, event):
		cursor_pos = self.cursorPosition()

		if event.key()==Qt.Key.Key_Left and cursor_pos==0:
			self.move_to(-1, 0)
		elif event.key()==Qt.Key.Key_Right and cursor_pos==len(self.text()):
			self.move_to(1, 0)
		elif event.key()==Qt.Key.Key_Up:
			self.move_to(0, -1)
		elif event.key()==Qt.Key.Key_Down:
			self.move_to(0, 1)
		else:
			super().keyPressEvent(event)

	def setCursorToEdge(self, dx):
		if dx<0:
			self.setCursorPosition(len(self.text()))
		else:
			self.setCursorPosition(0)

class CustomComboBox(NavigableMixin, QComboBox):
	def __init__(self, row, col, editable=False, placeholder="", parent=None):
		QComboBox.__init__(self, parent)
		NavigableMixin.__init__(self, row, col)
		self.setEditable(editable)

		self.user_selected = False

		if editable and self.lineEdit() is not None:
			self.lineEdit().setReadOnly(False)
			self.lineEdit().setPlaceholderText(placeholder)
			self.lineEdit().installEventFilter(self)
		else:
			self.setPlaceholderText(placeholder)

	def keyPressEvent(self, event):
		if event.type() == event.KeyPress:
			if event.key()==Qt.Key.Key_Left:
				if ((not self.isEditable()) or
					(self.isEditable() and self.lineEdit().cursorPosition()==0)):
					self.move_to(-1, 0)
				elif self.isEditable():
					self.lineEdit().setCursorPosition(self.lineEdit().cursorPosition()-1)
			elif event.key()==Qt.Key.Key_Right:
				if ((not self.isEditable()) or
					(self.isEditable() and self.lineEdit().cursorPosition()==len(self.currentText()))):
					self.move_to(1, 0)
				elif self.isEditable():
					self.lineEdit().setCursorPosition(self.lineEdit().cursorPosition()+1)
			elif event.key()==Qt.Key.Key_Up:
				if self.user_selected:
					self.setCurrentIndex(max(0, self.currentIndex()-1))
				else:
					self.move_to(0, -1)
			elif event.key()==Qt.Key.Key_Down:
				if self.user_selected:
					self.setCurrentIndex(min(self.currentIndex()+1, self.count()-1))
				else:
					self.move_to(0, 1)
			elif event.key()==Qt.Key.Key_Return or event.key()==Qt.Key.Key_Enter:
				if self.user_selected:
					self.user_selected = False
					self.hidePopup()
				else:
					self.user_selected = True
					self.showPopup()
			else:
				super().keyPressEvent(event)
		else:
			super().keyPressEvent(event)
	
	def setCursorToEdge(self, dx):
		if self.isEditable():
			self.lineEdit().selectAll()
			self.lineEdit().setFocus()
			if dx<0:
				self.lineEdit().setCursorPosition(len(self.currentText()))
			else:
				self.lineEdit().setCursorPosition(0)

	def focusInEvent(self, event):
		self.user_selected = False
		super().focusInEvent(event)
		self.hidePopup()

class FileType:
	alltype = "所有文件 (*)"
	text = "文本文件 (*.txt)"
	excel = "Excel 文件 (*.xlsx)"

class FilePicker(QWidget):
	def __init__(self, text="", filetype=FileType.alltype, parent=None):
		super().__init__(parent)
		layout = QGridLayout()
		self.button = QPushButton(text)
		self.line_edit = QLineEdit()
		self.line_edit.setReadOnly(True)
		self.filetype = filetype
		layout.addWidget(self.line_edit, 0, 0)
		layout.addWidget(self.button, 0, 1)

		self.button.clicked.connect(self.open_file_dialog)
		self.setLayout(layout)

	def open_file_dialog(self):
		options = QFileDialog.Options()
		file_name, _ = QFileDialog.getOpenFileName(
			self,
			"选择文件",
			os.path.expanduser("~/"),
			self.filetype,
			options=options
		)
		if file_name:
			self.process_file(file_name)

	def process_file(self, path):
		self.line_edit.setText(path)
		pass

	def get_path(self):
		return self.line_edit.text()
	
	def set_path(self, path):
		self.line_edit.setText(path)


# softwareWithWindow.py
import sys
import pandas as pd
from PyQt5.QtWidgets import (
    QApplication, QLabel, QWidget, QPushButton, QVBoxLayout, QHBoxLayout,
    QGridLayout, QMainWindow, QStackedWidget, QLineEdit,
    QTextEdit
)
import FuriganaAdditionPackaged as FAP
import CustomPyQt5 as CPQ

class TableWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        layout = QVBoxLayout()
        self.table = CPQ.DataFrameViewer()
        self.update_table()
        self.update_button = QPushButton("刷新表格")
        self.update_button.clicked.connect(self.update_table)

        layout.addWidget(self.update_button)
        layout.addWidget(self.table)

        self.setLayout(layout)

    def update_table(self):
        dic = FAP.Dictionary()
        self.table.load_data(dic.outputdf())

    
class SearchWindow(QWidget):
    def __init__(self, PlaceHolderText, ButtonText, parent=None):
        super().__init__(parent)
        self.line_edit = QLineEdit()
        self.line_edit.setPlaceholderText(PlaceHolderText)
        self.button_search = CPQ.CustomButton(0, 2, ButtonText)
        self.index_input = CPQ.CustomLineEdit(1, 0, "请输入需要删除的行数")
        self.indexType_input = CPQ.CustomComboBox(1, 1)
        self.button_delete = CPQ.CustomButton(1, 2, "删除")
        self.informText = QLabel()

        self.indexType_input.addItems(["原索引", "子索引"])
        self.init_ui()

        self.search_df = pd.DataFrame()

    def init_ui(self):
        layout = QGridLayout()
        layout.addWidget(self.line_edit, 0, 0, 1, 2)
        layout.addWidget(self.button_search, 0, 2)
        layout.addWidget(self.index_input, 1, 0)
        layout.addWidget(self.indexType_input, 1, 1)
        layout.addWidget(self.button_delete, 1, 2)
        layout.addWidget(self.informText, 2, 0)

        self.viewer = CPQ.DataFrameViewer()

        layout.addWidget(self.viewer, 3, 0, 2, 3)

        self.button_search.setOnClick(self.search)
        self.button_delete.setOnClick(self.delete)
        self.line_edit.returnPressed.connect(self.search)

        self.setLayout(layout)


    def search(self):
        current_text = self.line_edit.text()
        dic = FAP.Dictionary()
        df = dic.outputdf()
        self.search_df = pd.DataFrame(columns=df.columns)
        for i in self.search_df.columns:
            self.search_df[i] = self.search_df[i].astype(str)
        
        data_list = []
        for index, row in df.iterrows():
            if current_text in FAP.simplify(row["Japanese"]) or current_text in FAP.simplify(row["Kana"]):
                tempDic = row.to_list()
                tempDic.append(index)
                tempDic.append(len(data_list))
                data_list.append(tempDic)
        self.search_df = pd.DataFrame(data_list, columns=list(df.columns)+["Original Index", "Subtable Index"])
        self.search_df = self.search_df[["Original Index", "Subtable Index", "Japanese", "Kana", "Division", "Type", "Priority"]]
        self.viewer.load_data(self.search_df)

    def delete(self):
        dic = FAP.Dictionary()
        df = dic.outputdf()
        index = self.index_input.text()
        try:
            index = int(index)
        except:
            self.informText.setText("索引输入需为整数!")
            self.index_input.setText("")
            self.index_input.setFocus()
            return
        match(self.indexType_input.currentText()):
            case "原索引":
                if 0<=index<df.shape[0]:
                    dic.delete(index)
                    main_window = self.window()

                if isinstance(main_window, MainWindow):
                    setting_viewer = main_window.setting_viewer
                try:
                    backup_dic = FAP.Dictionary(setting_viewer.backup_dic_path.line_edit.text())
                    backup_dic.savedf(df)
                except:
                    pass

                    self.informText.setText("删除成功!")
                else:
                    self.informText.setText("索引超出原索引范围(0~{})!".format(df.shape[0]-1))
            case "子索引":
                subindex = int(self.search_df.at[index, "Original Index"])
                if 0<=index<self.search_df.shape[0]:
                    dic.delete(subindex)
                    self.informText.setText("删除成功!")
                else:
                    self.informText.setText("索引超出子索引范围(0~{})!".format(self.search_df.shape[0]-1))
        self.index_input.setText("")
        self.index_input.setFocus()
        return

class NewTermWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        layout = QGridLayout()

        self.init_ui()

        layout.addWidget(self.Japanese_input, 0, 0)
        layout.addWidget(self.Kana_input, 0, 1)
        layout.addWidget(self.Division_input, 0, 2)
        layout.addWidget(self.Type_input, 1, 0)
        layout.addWidget(self.Priority_input, 1, 1)
        layout.addWidget(self.button_reject, 1, 2)
        layout.addWidget(self.button_auto, 2, 0)
        layout.addWidget(self.button_addition, 2, 1)
        layout.addWidget(self.button_agree, 2, 2)
        layout.addWidget(self.InformText, 3, 0, 1, 3)

        self.setLayout(layout)

    def init_ui(self):
        self.Japanese_input = CPQ.CustomLineEdit(0, 0, "请输入日语单词")
        self.Kana_input = CPQ.CustomLineEdit(0, 1, "请输入单词对应的读音")
        self.Division_input = CPQ.CustomComboBox(0, 2, True, "请输入分割方式")
        self.Type_input = CPQ.CustomComboBox(1, 0, False, "请选择词性")
        self.Priority_input = CPQ.CustomComboBox(1, 1, False, "请选择优先级")
        self.button_reject = CPQ.CustomButton(1, 2, "取消")
        self.button_auto = CPQ.CustomButton(2, 0, "自动分割")
        self.button_addition = CPQ.CustomButton(2, 1, "添加")
        self.button_agree = CPQ.CustomButton(2, 2, "确认")
        self.InformText = QTextEdit()
        

        self.Division_input.addItems(["0", "0/-1", "0\\-1", "-1/0", "0/-1/0", "0/-1\\-1",
                                      "0/-1/0/-1", "-1/0/-1", "0/-1/0\\-1"])
        self.Type_input.addItems(["名詞", "五段", "上下", "形容", "サ行", "タ行"])
        self.Priority_input.addItems(["0", "1", "2"])

        self.button_addition.setOnClick(self.addition_click_on)

        self.InformText.setPlaceholderText("等待单词输入中...")
        self.InformText.setReadOnly(True)

        self.Agree_Reject_Availability = False
        self.button_agree.setOnClick(self.agree_click_on)
        self.button_reject.setOnClick(self.reject_click_on)
        self.button_auto.setOnClick(self.AutoDivision_click_on)

        self.term_list = [self.Japanese_input.text(), self.Kana_input.text(),
                          self.Division_input.currentText(), self.Type_input.currentText(),
                          self.Priority_input.currentText()]
        
    def update_list(self):
        self.term_list = [self.Japanese_input.text(), self.Kana_input.text(),
                          self.Division_input.currentText(), self.Type_input.currentText(),
                          self.Priority_input.currentText()]
    
    def addition_click_on(self):
        self.update_list()
        if FAP.Term(self.term_list).isLegal():
            dic = FAP.Dictionary()
            addition = FAP.Addition()
            if dic.isIndf(self.term_list):
                informText = "该输入已经存在!"
                self.InformText.setText(informText)
                self.Agree_Reject_Availability = False
            else:
                informText = "该输入合法,标准输出形式如下:\n"+addition.printform(self.term_list)
                self.InformText.setText(informText)
                self.Agree_Reject_Availability = True
                self.button_agree.setFocus()
        else:
            informtext = "该输入非法!"
            self.InformText.setText(informtext)
            self.Agree_Reject_Availability = False

    def agree_click_on(self):
        if self.Agree_Reject_Availability:
            informText = "添加成功!"
            self.InformText.setText(informText)
            dic = FAP.Dictionary()
            df = dic.dfappend(self.term_list)
            dic.savedf(df)

            main_window = self.window()
            if isinstance(main_window, MainWindow):
                setting_viewer = main_window.setting_viewer
            try:
                backup_dic = FAP.Dictionary(setting_viewer.backup_dic_path.line_edit.text())
                backup_dic.savedf(df)
            except:
                pass

            self.Agree_Reject_Availability = False
            self.Japanese_input.setText("")
            self.Kana_input.setText("")
            self.Japanese_input.setFocus()

    def reject_click_on(self):
        if self.Agree_Reject_Availability:
            informText = "已取消添加操作"
            self.InformText.setText(informText)
            self.Agree_Reject_Availability = False

    def AutoDivision_click_on(self):
        self.update_list()
        tempTerm = FAP.Term(self.term_list)
        try:
            tempTerm = tempTerm.AutoDivision()
        except:
            informText = "不合法的单词,假名和类型输入\n无法自动分割"
            self.InformText.setText(informText)
            return None
        self.Japanese_input.setText(tempTerm[0])
        self.Kana_input.setText(tempTerm[1])
        self.Division_input.setCurrentText(tempTerm[2])
        self.Type_input.setCurrentText(tempTerm[3])
        self.Priority_input.setCurrentText(tempTerm[4])
        self.button_addition.setFocus()
    
class InTextWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.button_operation = QPushButton("添加注音")
        self.text_edit = QTextEdit()
        intext = FAP.InText()
        self.text_edit.setText(intext.read_text())
        layout = QHBoxLayout()
        layout.addWidget(self.button_operation)
        layout.addWidget(self.text_edit)

        self.button_operation.clicked.connect(self.operation)

        self.setLayout(layout)

    def operation(self):
        intext = FAP.InText()
        intext.write_text(self.text_edit.toPlainText())
        addition = FAP.Addition()
        addition.operation()
        
        main_window = self.window()
        if isinstance(main_window, MainWindow):
            setting_viewer = main_window.setting_viewer
        try:
            backup_intext = FAP.InText(setting_viewer.backup_in_path.line_edit.text())
            backup_intext.write_text(intext.read_text())
        except:
            pass
        try:
            backup_outtext = FAP.OutText(setting_viewer.backup_out_path.line_edit.text())
            addition.operation(outtext=backup_outtext)
        except:
            pass


class OutTextWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.text_edit = QTextEdit()
        self.update_outtext()
        self.button_update = QPushButton("刷新输出文档")
        newtermwindow = NewTermWindow()
        layout = QHBoxLayout()
        layout.addWidget(self.button_update)
        layout.addWidget(self.text_edit)
        layout.addWidget(newtermwindow)

        self.button_update.clicked.connect(self.update_outtext)

        self.setLayout(layout)

    def update_outtext(self):
        addition = FAP.Addition()
        addition.operation()
        outtext = FAP.OutText()
        self.text_edit.setText(outtext.read_text())
        self.text_edit.setReadOnly(True)

        main_window = self.window()
        if isinstance(main_window, MainWindow):
            setting_viewer = main_window.setting_viewer
        try:
            backup_outtext = FAP.OutText(setting_viewer.backup_out_path.line_edit.text())
            addition.operation(outtext=backup_outtext)
        except:
            pass

class SettingWindow(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        LastSetting = CPQ.SettingJson(FAP.APP_NAME)
        self.settings = LastSetting.load_settings()

        self.backup_dic_path = CPQ.FilePicker("选择备份表格", CPQ.FileType.excel)
        self.backup_in_path = CPQ.FilePicker("选择备份输入", CPQ.FileType.text)
        self.backup_out_path = CPQ.FilePicker("选择备份输出", CPQ.FileType.text)

        self.backup_dic_path.set_path(self.settings.get("backup_dic_path", ""))
        self.backup_in_path.set_path(self.settings.get("backup_in_path", ""))
        self.backup_out_path.set_path(self.settings.get("backup_out_path", ""))

        layout = QGridLayout()
        layout.addWidget(self.backup_dic_path, 0, 0)
        layout.addWidget(self.backup_in_path, 1, 0)
        layout.addWidget(self.backup_out_path, 2, 0)

        self.setLayout(layout)

    def get_paths(self):
        return {
            "backup_dic_path": self.backup_dic_path.get_path(),
            "backup_in_path": self.backup_in_path.get_path(),
            "backup_out_path": self.backup_out_path.get_path()
        }
    
    def closeEvent(self, event):
        paths = self.get_paths()
        settingjson = CPQ.SettingJson(FAP.APP_NAME)
        settingjson.save_settings(paths)
        super().closeEvent(event)
        
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("FAP Software")
        self.resize(1000, 600)

        main_widget = QWidget()
        self.setCentralWidget(main_widget)

        main_layout = QVBoxLayout(main_widget)
        self.button_layout = QHBoxLayout()
        self.stacked_widget = QStackedWidget()
        self.setting_viewer = SettingWindow()

        main_layout.addLayout(self.button_layout, 1)
        main_layout.addWidget(self.stacked_widget, 4)

        self.add_page("Dic", self.create_page_dic())
        self.add_page("In Text", self.create_page_in_text())
        self.add_page("Out Text", self.create_page_out_text())
        self.add_page("Setting", self.setting_viewer)

    def add_page(self, button_text, page_widget):
        btn = QPushButton(button_text)
        btn.clicked.connect(lambda: self.stacked_widget.setCurrentWidget(page_widget))
        self.button_layout.addWidget(btn)
        self.stacked_widget.addWidget(page_widget)

    def create_page_dic(self):
        widget = QWidget()
        layout = QGridLayout()
        searchwindow = SearchWindow("请输入要查找的文本", "查找")       
        newtermwindow = NewTermWindow()
        table_viewer = TableWindow()

        layout.addWidget(table_viewer, 0, 0, 6, 1)
        layout.addWidget(searchwindow, 0, 1, 3, 1)
        layout.addWidget(newtermwindow, 3, 1, 3, 1)
        widget.setLayout(layout)
        return widget
    
    def create_page_in_text(self):
        intextwindow = InTextWindow()
        return intextwindow
    
    def create_page_out_text(self):
        outtextwindow = OutTextWindow()
        return outtextwindow
    
    def closeEvent(self, event):
        paths = self.setting_viewer.get_paths()
        settingjson = CPQ.SettingJson(FAP.APP_NAME)
        settingjson.save_settings(paths)
        return super().closeEvent(event)

if __name__ == "__main__":
    pass